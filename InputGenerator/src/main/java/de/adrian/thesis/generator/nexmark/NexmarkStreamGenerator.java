package de.adrian.thesis.generator.nexmark;/*
   NEXMark Generator -- Niagara Extension to XMark Data Generator

   Acknowledgements:
   The NEXMark Generator was developed using the xmlgen generator 
   from the XMark Benchmark project as a basis. The NEXMark
   generator generates streams of auction elements (bids, items
   for auctions, persons) as opposed to the auction files
   generated by xmlgen.  xmlgen was developed by Florian Waas.
   See http://www.xml-benchmark.org for information.

   Copyright (c) Dept. of  Computer Science & Engineering,
   OGI School of Science & Engineering, OHSU. All Rights Reserved.

   Permission to use, copy, modify, and distribute this software and
   its documentation is hereby granted, provided that both the
   copyright notice and this permission notice appear in all copies
   of the software, derivative works or modified versions, and any
   portions thereof, and that both notices appear in supporting
   documentation.

   THE AUTHORS AND THE DEPT. OF COMPUTER SCIENCE & ENGINEERING 
   AT OHSU ALLOW USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION, 
   AND THEY DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES 
   WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.

   This software was developed with support from NSF ITR award
   IIS0086002 and from DARPA through NAVY/SPAWAR 
   Contract No. N66001-99-1-8098.

*/

import de.adrian.thesis.generator.nexmark.data.AuctionType;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.concurrent.ThreadLocalRandom;

public class NexmarkStreamGenerator {

    private static final Logger LOG = LogManager.getLogger(NexmarkStreamGenerator.class);

    private static final boolean LIMIT_ATTRIBUTES = false;

    private final String NEWLINE = System.lineSeparator();

    // will generate bids, items and persons in a ratio of 10 bids/item 5 items/person
    private final ThreadLocalRandom random = ThreadLocalRandom.current(); // Maybe replace with ThreadLocalRandom
    private final SimpleCalendar calendar = new SimpleCalendar(random);
    private final Persons persons = new Persons(); // for managing person ids
    private final Bids bids = new Bids();
    private final OpenAuctions openAuctions = new OpenAuctions(calendar); // for managing open auctions
    private final PersonGenerator personGenerator = new PersonGenerator();

    private Buffer buffer;
    private BufferedWriter writer;

    private static NexmarkStreamGenerator INSTANCE;

    private NexmarkStreamGenerator() {
    }

    public static NexmarkStreamGenerator GetInstance() {

        if (INSTANCE == null) {
            INSTANCE = new NexmarkStreamGenerator();
        }

        return INSTANCE;
    }

    public void generateStream(BufferedWriter writer) throws IOException {
        buffer = new Buffer();
        this.writer = writer;

        if (LIMIT_ATTRIBUTES) {
            System.out.println("WARNING: LIMITING ATTRIBUTES");
        }

//        for (int i = 0; i < NUMBER_OF_INITIAL_AUCTIONS; i++) {
//            initMyBuf();
//            generateAuction(buffer);
//            writeMyBuf();
//        }

        // TODO Introduce additional layer of indirection for varying the persons, auctions and bids per step
        // TODO Maybe, do

        // Per step, generate 1 person, 5 actions and 10 bids
//        for (int i = 0; i < numGenCalls; i++) {
//            initMyBuf();
//
//            // Generate 1 person every 10th call
//            if (random.nextInt(10) == 0) {
//                generatePerson();
//            }
//
//            // want on average 1 item and 10 bids
//            int numItems = random.nextInt(3); // should average 1
//            for (int j = 0; j < numItems; j++) {
//                generateAuction(buffer);
//            }
//
//            int numBids = random.nextInt(21); // should average 10
//            generateBid(buffer, numBids);
//
//            writeMyBuf();
//        }
        writer.close();
    }

    private void initMyBuf() {
        buffer.clear();
        buffer.append(NEWLINE);
    }

    private void writeMyBuf() throws IOException {
        writer.write(buffer.array(), 0, buffer.length());
    }

    private void generateBid(Buffer buffer, int numBids) {

        calendar.incrementTime();
        buffer.append(NEWLINE);

        for (int i = 0; i < numBids; i++) {

            int bidId = bids.getNewId();

            buffer.append("bid_id=");
            buffer.append(bidId);

            int itemId = openAuctions.getExistingId();

            buffer.append(",auction_id=");
            buffer.append(itemId);

            buffer.append(",time=");
            buffer.append(calendar.getTimeInSecs()); // Datetime is in seconds
            // Alternate time stamps
            //myb.append(System.currentTimeMillis() - random.nextInt(MAXINCREMENT_MILLISEC));
            //ts = System.currentTimeMillis() * WARP + DELAY;
            //myb.append(ts);

            buffer.append(",person_ref=");
            buffer.append(persons.getExistingId());

            buffer.append(",bid=");
            buffer.append(openAuctions.increasePrice(itemId));
            buffer.append(NEWLINE);
        }
    }

    public String generateAuction() {
        return generateAuction(LIMIT_ATTRIBUTES);
    }

    /**
     * Generates auctions. Previous note: A Person may be selling items for a different regions.
     * Does not matter for out use case. Schema:
     * auction_id,item_id,seller_id,price,category_id,quantity,type,start,end
     *
     * @param limitAttributes Whether to use the full output
     */
    public String generateAuction(boolean limitAttributes) {
        calendar.incrementTime();

        StringBuilder builder = new StringBuilder(200);

        long currentTimeMillis = System.currentTimeMillis();

        builder.append(currentTimeMillis);
        builder.append(",");

        int auctionId = openAuctions.getNewId();
        builder.append(auctionId);

        // Assume itemId and openAuctionId are same, therefore only one auction per item allowed
        builder.append(",");
        builder.append(auctionId);

        builder.append(",");
        builder.append(persons.getExistingId());

        builder.append(",");
        builder.append((int) Math.round((openAuctions.getCurrPrice(auctionId)) * (1.2 + (random.nextDouble() + 1))));

        // Original benchmark allows up to 10 categories, we allow an item to be in one category
        builder.append(",");
        int category_id = random.nextInt(PersonGenerator.NUM_CATEGORIES);
        builder.append(category_id);

        builder.append(",");
        int quantity = 1 + random.nextInt(10);
        builder.append(quantity);

//        builder.append(",");
//        builder.append(AuctionType.AUCTION_TYPE[random.nextInt(AuctionType.AUCTION_TYPE.length)]);

        builder.append(",");
        builder.append(calendar.getTimeInSecs());
        builder.append(",");
        builder.append(openAuctions.getEndTime(auctionId));

        return builder.toString();
    }

    public String generatePerson() {
        return generatePerson(LIMIT_ATTRIBUTES);
    }

    /**
     * Generates persons based on the following schema:
     * person_id,name,email_address,phone,street,city,country,province,zipcode,homepage,creditcard
     */
    public String generatePerson(boolean limitAttributes) {
        calendar.incrementTime();

        StringBuilder builder = new StringBuilder(200);

        long currentTimeMillis = System.currentTimeMillis();

        builder.append(currentTimeMillis);
        builder.append(",");

        personGenerator.generateValues(openAuctions); // person object is reusable now

        builder.append(String.valueOf(persons.getNewId()));

        builder.append(",");
        builder.append(personGenerator.name);

        builder.append(",");
        builder.append(personGenerator.email);

        builder.append(",");
        builder.append(personGenerator.phone);

        // TODO Bug in street generation? Multiple St's
        builder.append(",");
        builder.append(personGenerator.address.street);

        builder.append(",");
        builder.append(personGenerator.address.city);

        builder.append(",");
        builder.append(personGenerator.address.country);

        builder.append(",");
        builder.append(personGenerator.address.province);

        builder.append(",");
        builder.append(personGenerator.address.zipcode);

        builder.append(",");
        builder.append(personGenerator.homepage);

        builder.append(",");
        builder.append(personGenerator.creditcard);

        return builder.toString();
    }
}

